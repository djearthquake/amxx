/*
*
*   SSSSSSSSSSSSSSS PPPPPPPPPPPPPPPPP     iiii  NNNNNNNN        NNNNNNNNXXXXXXX       XXXXXXX
* SS:::::::::::::::SP::::::::::::::::P   i::::i N:::::::N       N::::::NX:::::X       X:::::X
*S:::::SSSSSS::::::SP::::::PPPPPP:::::P   iiii  N::::::::N      N::::::NX:::::X       X:::::X
*S:::::S     SSSSSSSPP:::::P     P:::::P        N:::::::::N     N::::::NX::::::X     X::::::X
*S:::::S              P::::P     P:::::Piiiiiii N::::::::::N    N::::::NXXX:::::X   X:::::XXX
*S:::::S              P::::P     P:::::Pi:::::i N:::::::::::N   N::::::N   X:::::X X:::::X
* S::::SSSS           P::::PPPPPP:::::P  i::::i N:::::::N::::N  N::::::N    X:::::X:::::X
*  SS::::::SSSSS      P:::::::::::::PP   i::::i N::::::N N::::N N::::::N     X:::::::::X
*    SSS::::::::SS    P::::PPPPPPPPP     i::::i N::::::N  N::::N:::::::N     X:::::::::X
*       SSSSSS::::S   P::::P             i::::i N::::::N   N:::::::::::N    X:::::X:::::X
*            S:::::S  P::::P             i::::i N::::::N    N::::::::::N   X:::::X X:::::X
*            S:::::S  P::::P             i::::i N::::::N     N:::::::::NXXX:::::X   X:::::XXX
*SSSSSSS     S:::::SPP::::::PP          i::::::iN::::::N      N::::::::NX::::::X     X::::::X
*S::::::SSSSSS:::::SP::::::::P          i::::::iN::::::N       N:::::::NX:::::X       X:::::X
*S:::::::::::::::SS P::::::::P          i::::::iN::::::N        N::::::NX:::::X       X:::::X
* SSSSSSSSSSSSSSS   PPPPPPPPPP          iiiiiiiiNNNNNNNN         NNNNNNNXXXXXXX       XXXXXXX
*
*──────────────────────────────▄▄
*──────────────────────▄▄▄▄▄▄▄▄▌▐▄
*─────────────────────█▄▄▄▄▄▄▄▄▌▐▄█
*────────────────────█▄▄▄▄▄▄▄█▌▌▐█▄█
*──────▄█▀▄─────────█▄▄▄▄▄▄▄▌░▀░░▀░▌
*────▄██▀▀▀▀▄──────▐▄▄▄▄▄▄▄▐ ▌█▐░▌█▐▌
*──▄███▀▀▀▀▀▀▀▄────▐▄▄▄▄▄▄▄▌░░░▄▄▌░▐
*▄████▀▀▀▀▀▀▀▀▀▀▄──▐▄▄▄▄▄▄▄▌░░▄▄▄▄░▐
*████▀▀▀▀▀▀▀▀▀▀▀▀▀▄▐▄▄▄▄▄▄▌░▄░░▀▀░░▌
*▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐▄▄▄▄▄▄▌░▐▀▄▄▄▄▀
*▒▒▒▒▄▄▀▀▀▀▀▀▀▀▄▄▄▄▀▀█▄▄▄▄▄▌░░░░░▌
*▒▄▀▀░░░░░░░░░░░░░░░░░░░░░░░░░░░░▌
*▒▌░░░░░▀▄░░░░░░░░░░░░░░░▀▄▄▄▄▄▄░▀▄▄▄▄▄
*▒▌░░░░░░░▀▄░░░░░░░░░░░░░░░░░░░░▀▀▀▀▄░▀▀▀▄
*▒▌░░░░░░░▄▀▀▄░░░░░░░░░░░░░░░▀▄░▄░▄░▄▌░▄░▄▌
*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
*
*
*
*
*
* __..__  .  .\  /
*(__ [__)*|\ | ><
*.__)|   || \|/  \
*
*    Wpn_Hivehand Plugin.
*    Copyleft (C) 2021 .sρiηX҉.
*
*    This program is free software: you can redistribute it and/or modify
*    it under the terms of the GNU Affero General Public License as
*    published by the Free Software Foundation, either version 3 of the
*    License, or (at your option) any later version.
*
*    This program is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU Affero General Public License for more details.
*
*    You should have received a copy of the GNU Affero General Public License
*    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*    Credits: AMXX DEV TEAM for everything including adminhelp.sma.
*    AMX Mod X, based on AMX Mod by Aleksander Naszko ("OLO").
*/
/* - - - - - - - - - - -

    AMX Mod X script.

      | Author  : v1.0.4 < Arkshine
      | Plugin  : WPN Hivehand ( HL1 )
      | Version : v1.0.4

    (!) Support : http://forums.space-headed.net/viewtopic.php?t=369

    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation; either version 2 of the License, or (at
    your option) any later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software Foundation,
    Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~


    Description :
    - - - - - - -
        Basically, it's almost the same weapon that you can see in Half-life 1.

        The Hivehand is an organic weapon used by Alien grunts, this is actually a sort of insect hive,
        biologically engineered into a living assault rifle. Pressing primary attack releases alien 'hornets'
        that will seek out enemies and home in on them; the rate of fire is quite slow and the hornets do not
        do an impressive amount of damage, but the Hivehand has the huge advantage of being able to fire around
        corners and chase after retreating enemies. The secondary attack fires hornets rapidly; in this case
        the insects will not home in on enemies, but this mode can be useful for unleashing a large amount
        of damage in a hurry.

        The Hivehand has an infinite ammo supply as it can produce an unlimited number of hornets;
        though it can only have eight hornets ready for firing at a time, insects that are fired are quickly replaced.

        A full description can be found here : http://half-life.wikia.com/wiki/Hivehand .


    Requirement :
    - - - - - - -
        * CS 1.6 / CZ / DoD / TFC / TS
        * AMX Mod X 1.7x or higher.
        * WeaponMod / GameInfo ( the latest version )


    Modules :
    - - - - -
        * Fakemeta


    Changelog :
    - - - - - -
        v1.0.4 : [ 14 nov 2021]
            (!) Fixed. Compile and indefinate freeze on wpn_gameinfo_cs.sma. Made ZP optional as original. -SPiNX
            (!) Cleaned up ZP NiHiLaNTh edits.
            (+) Added a post think.

        v1.0.3 : [ 6 jul 2008 ]

            (!) Fixed. Monsters was not tracked by hornet.

        v1.0.2 : [ 3 jul 2008 ]

            (+) Added weapon idle system.
            (+) Added a check for hornet to not track players if wpn_friendlyfire is disabled.
            (!) Fixed. Sometimes hornet was turning around of player without touch it at the end.
            (*) Changed method ( for hornet ) to find the best visible enemy.
            (*) Minor optimizations / changes.

            An alternative and great model is now provided.

        v1.0.1 : [ 23 may 2008 ]

            (!) Fixed. Ammo was not updated in real-time at the HUD while reloading.

        v1.0.0 : [ 22 may 2008 ]

            (+) Initial release.


    Credits :
    - - - - -
        * HLSDK
        * DevconeS
        * VEN

- - - - - - - - - - - */

#include <amxmodx>
#include <fakemeta>
#include <weaponmod>
#include <weaponmod_stocks>
#include <xs>

  #tryinclude <zombieplague>
  ///#define zombieplague

    #if defined zombieplague
        #define Plugin  "[ZP]WPN Hivehand"
    #else
        #define Plugin  "WPN Hivehand"
    #endif

    #define Version "1.0.4"
    #define Author  ".sρiηX҉.Arkshine"

/* - - - - - - -
 |   Uncomment if you want to use the alternative model. |
                                           - - - - - - - */
    // #define ALTERNATIVE_MODEL

/* - - -
 |  Customization  |
             - - - */
    #define HIVEHAND_REFIRE_PRI  0.25   // Refire rate for primary attack ( float ).
    #define HIVEHAND_REFIRE_SEC  0.1    // Refire rate for secondary attack ( float ).
    #define HIVEHAND_SPEED       250.0  // Player's speed when holding the weapon.
    #define HIVEHAND_AMMO        8      // Max hornets.
    #define HIVEHAND_COST        8340   // Cost of the weapon.
    #define HIVEGUN_REGEN_SPEED  0.5    // Regenerate speed. ( 1 hornet by x second ) ( float ).

    #define HORNET_RED_SPEED     600.0  // Red hornet speed ( float ).
    #define HORNET_ORANGE_SPEED  800.0  // Orage hornet speed ( float ).
    #define HORNET_BUZZ_VOLUME   0.8    // Buzz volume ( float ).
    #define HORNET_FOV           0.1    // hornet's field of vision | 0.9 = +- 25 degrees ( float ).
    #define HORNET_SEARCH_RADIUS 512.0  // How far should the hornets searh enemy? ( float ).
    #define HORNET_DAMAGE        8      // Damage by hornet.

/* - - -
 |  Weapon information   |
                   - - - */
    new
        gs_WpnName [] = "Hivehand",
        gs_WpnShort[] = "hivehand";

/* - - -
 |  Weapon model   |
             - - - */
    new
    #if !defined ALTERNATIVE_MODEL
        gs_Model_P[] = "models/p_hgun.mdl",
        gs_Model_V[] = "models/v_hgun.mdl",
        gs_Model_W[] = "models/w_hgun.mdl";
    #else
        gs_Model_P[] = "models/p_alt_hgun.mdl",
        gs_Model_V[] = "models/v_alt_hgun.mdl",
        gs_Model_W[] = "models/w_alt_hgun.mdl";
    #endif

/* - - -
 |  Hornet fire sounds   |
                   - - - */
    new const
        gs_Fire1Sound[] = "agrunt/ag_fire1.wav",
        gs_Fire2Sound[] = "agrunt/ag_fire2.wav",
        gs_Fire3Sound[] = "agrunt/ag_fire3.wav";

/* - - -
 |  Hornet fire sounds   |
                   - - - */
    new const
        gs_Hit1Sound[] = "hornet/ag_hornethit1.wav",
        gs_Hit2Sound[] = "hornet/ag_hornethit2.wav",
        gs_Hit3Sound[] = "hornet/ag_hornethit3.wav";

/* - - -
 |  Hornet buzz sounds   |
                   - - - */
    new const
        gs_Buzz1Sound[] = "hornet/ag_buzz1.wav",
        gs_Buzz2Sound[] = "hornet/ag_buzz2.wav",
        gs_Buzz3Sound[] = "hornet/ag_buzz3.wav";

/* - - -
 |  Hornet model  |
            - - - */
    new
        gs_HornetModel[] = "models/hornet.mdl";

/* - - -
 |    Sequence   |
           - - - */
    enum
    {
        hgun_idle1,
        hgun_fidgetsway,
        hgun_fidgetshake,
        hgun_down,
        hgun_up,
        hgun_shoot
    };


/* - - -
 |    Others stuffs   |
                - - - */
    #define FCVAR_FLAGS ( FCVAR_SERVER | FCVAR_SPONLY | FCVAR_EXTDLL | FCVAR_UNLOGGED )

    #define HORNET_TYPE_RED      0
    #define HORNET_TYPE_ORANGE   1

    #define NOT_IN_WATER  0
    #define HEAD_IN_WATER 3

    #define MAX_CLIENTS 32

    enum e_Firemode
    {
        Track = 1,
        Fast,
        Die
    };

    enum e_Coord
    {
        Float:x,
        Float:y,
        Float:z
    };

    enum
    {
        StartTrack = 1,
        StartDart,
        TrackTarget,
        RemoveHornet
    }

    new const gs_HornetClassname[] = "wpn_hornet";

    new Float:gf_RechargeTime  [ MAX_CLIENTS + 1 ];
    new Float:gf_TimeWeaponIdle[ MAX_CLIENTS + 1 ];

    new gi_Hornet[ MAX_CLIENTS + 1 ];
    new gi_Weapon[ MAX_CLIENTS + 1 ];

    new gi_Weaponid;
    new gi_HornetClass;
    new gi_MaxEntities;
    new gi_FriendlyFire;

    new gi_HornetTrail;
    new gi_FirePhase;
    
    new bool:b_ReadyFire[MAX_PLAYERS+1]
/* - - -
 |    Custom fields   |
                - - - */

    #define HG_FLY_SPEED   pev_fuser4
    #define HG_FIRE_MODE   pev_iuser2
    #define HG_TYPE_COLOR  pev_iuser3
    #define HG_THINK_STEP  pev_iuser4
    #define HG_ENEMY_LKP   pev_vuser4
    #define HG_STOP_ATTACK pev_ltime

/* - - -
 |    Macro   |
        - - - */
    #if !defined charsmax
        #define charsmax(%1)  ( sizeof ( %1 ) - 1 )
    #endif


public plugin_precache ()
{
    // -- Weapon models
    precache_model ( gs_Model_P );
    precache_model ( gs_Model_V );
    precache_model ( gs_Model_W );

    // -- Hornet model
    precache_model ( gs_HornetModel );

    // -- Hornet fire sounds
    precache_sound ( gs_Fire1Sound );
    precache_sound ( gs_Fire2Sound );
    precache_sound ( gs_Fire3Sound );

    // -- Hornet buzz sounds
    precache_sound ( gs_Buzz1Sound );
    precache_sound ( gs_Buzz2Sound );
    precache_sound ( gs_Buzz3Sound );

    // -- Hornet hit sounds
    precache_sound ( gs_Hit1Sound );
    precache_sound ( gs_Hit2Sound );
    precache_sound ( gs_Hit3Sound );

    // -- Sprite
    gi_HornetTrail = precache_model ( "sprites/laserbeam.spr" );
}


public plugin_init ()
{
    register_plugin ( Plugin, Version, Author );
    register_cvar ( "wpn_hh_version", Version, FCVAR_FLAGS );

    #if defined zombieplague
    // Item ID
    new gi_ItemHornet;

    Register our new extra item
    gi_ItemHornet = zp_register_extra_item("Hornet", 20, ZP_TEAM_ZOMBIE);
    #endif

    register_forward ( FM_PlayerPreThink, "fwd_PreThink" );
    register_forward ( FM_PlayerPostThink, "fwd_PostThink" );
    register_forward ( FM_Think, "fwd_Think" );
    register_forward ( FM_Touch, "fwd_Touch" );
}


public plugin_cfg ()
{
    gi_HornetClass  = engfunc ( EngFunc_AllocString, "info_null" );
    gi_MaxEntities  = global_get ( glb_maxEntities );
    gi_FriendlyFire = get_cvar_pointer ( "wpn_friendlyfire" ) ? get_pcvar_num ( get_cvar_pointer ( "wpn_friendlyfire" ) ) : register_cvar("wpn_friendlyfire", "1")

    CreateWeapon ();
}


public client_disconnected ( id )
{
    gf_RechargeTime  [ id ] = 0.0;
    gf_TimeWeaponIdle[ id ] = 0.0;
}


CreateWeapon ()
{
    new i_Weapon_id = wpn_register_weapon ( gs_WpnName, gs_WpnShort );

    if ( i_Weapon_id == -1 )
        return;


    wpn_set_string ( i_Weapon_id, wpn_viewmodel  , gs_Model_V );
    wpn_set_string ( i_Weapon_id, wpn_weaponmodel, gs_Model_P );
    wpn_set_string ( i_Weapon_id, wpn_worldmodel , gs_Model_W );

    wpn_register_event ( i_Weapon_id, event_attack1, "Hornet_PrimaryAttack"   );
    wpn_register_event ( i_Weapon_id, event_attack2, "Hornet_SecondaryAttack" );
    wpn_register_event ( i_Weapon_id, event_draw   , "Hornet_Deploy"  );
    wpn_register_event ( i_Weapon_id, event_hide   , "Hornet_Holster" );

    wpn_set_float ( i_Weapon_id, wpn_refire_rate1, HIVEHAND_REFIRE_PRI );
    wpn_set_float ( i_Weapon_id, wpn_refire_rate2, HIVEHAND_REFIRE_SEC );
    wpn_set_float ( i_Weapon_id, wpn_run_speed, HIVEHAND_SPEED );

    wpn_set_integer ( i_Weapon_id, wpn_ammo1, HIVEHAND_AMMO );
    wpn_set_integer ( i_Weapon_id, wpn_count_bullets2, 0 );
    wpn_set_integer ( i_Weapon_id, wpn_cost, HIVEHAND_COST );

    gi_Weaponid = i_Weapon_id;
}

#if defined zombieplague

public zp_extra_item_selected(id, itemid)
if (itemid == gi_ItemHornet) /*someone bought our extra item*/
    client_print(id, print_chat, "[ZP] You can use alternate fire too.") && wpn_give_weapon(gi_Weaponid, id, 8, 0)

#endif

public Hornet_PrimaryAttack ( id )
    Hornet_Fire ( id, e_Firemode:Track );

public Hornet_SecondaryAttack ( id )
    Hornet_Fire ( id, e_Firemode:Fast );

public Hornet_Deploy ( id )
    wpn_playanim ( id, hgun_up );

public Hornet_Holster ( id )
{
    wpn_playanim ( id, hgun_down );

    if ( IsAmmoEmpty ( id, usr_wpn_ammo1 ) )
        wpn_set_userinfo ( id, usr_wpn_ammo1, gi_Weapon[ id ],  wpn_get_userinfo ( id, usr_wpn_ammo1, gi_Weapon[ id ] ) + 1 );

}


Hornet_Fire ( const id,  const e_Firemode:i_Type )
{
    if ( IsAmmoEmpty ( id, usr_wpn_ammo1 ) )
        return PLUGIN_HANDLED;

    if ( !Hornet_Create ( id, i_Type ) )
        return PLUGIN_CONTINUE;

    static Float:f_Time; f_Time = get_gametime ();
    gf_RechargeTime[ id ] = f_Time + 0.5;

    Hornet_Spawn ( gi_Hornet[ id ], i_Type );
    Hornet_FireEffect ( id );

    wpn_set_userinfo ( id, usr_wpn_ammo1, gi_Weapon[ id ], wpn_get_userinfo ( id, usr_wpn_ammo1, gi_Weapon[ id ] ) - 1 );
    gf_TimeWeaponIdle[ id ] = f_Time + random_float ( 10.0, 15.0 );

    return PLUGIN_CONTINUE;
}


Hornet_Create ( const id, const e_Firemode:i_Type )
{
    gi_Hornet[ id ] = engfunc ( EngFunc_CreateNamedEntity, gi_HornetClass );

    if ( !gi_Hornet[ id ] )
        return FM_NULLENT;

    set_pev ( gi_Hornet[ id ], pev_classname, gs_HornetClassname );

    static Float:vf_Forward [ e_Coord ], Float:vf_Velocity[ e_Coord ];
    static Float:vf_Right   [ e_Coord ], Float:vf_Up      [ e_Coord ];
    static Float:vf_StartPos[ e_Coord ], Float:vf_vAngles [ e_Coord ];

    EyePosition ( id, vf_StartPos );

    pev ( id, pev_v_angle, vf_vAngles );
    engfunc( EngFunc_MakeVectors, vf_vAngles );

    global_get ( glb_v_forward, vf_Forward );
    global_get ( glb_v_right, vf_Right );
    global_get ( glb_v_up, vf_Up );

    vf_StartPos[ x ] = vf_StartPos[ x ] + vf_Forward[ x ] * 16.0 + vf_Right[ x ] * 8.0 + vf_Up[ x ] * -12.0;
    vf_StartPos[ y ] = vf_StartPos[ y ] + vf_Forward[ y ] * 16.0 + vf_Right[ y ] * 8.0 + vf_Up[ y ] * -12.0;
    vf_StartPos[ z ] = vf_StartPos[ z ] + vf_Forward[ z ] * 16.0 + vf_Right[ z ] * 8.0 + vf_Up[ z ] * -12.0;

    switch ( i_Type )
    {
        case Track :
        {
            set_pev ( gi_Hornet[ id ], pev_origin, vf_StartPos );
            set_pev ( gi_Hornet[ id ], pev_angles, vf_vAngles );
            set_pev ( gi_Hornet[ id ], pev_owner, id );

            xs_vec_mul_scalar ( vf_Forward, 300.0, vf_Velocity );
            set_pev ( gi_Hornet[ id ], pev_velocity, vf_Velocity );
        }
        case Fast  :
        {
            switch ( ++gi_FirePhase )
            {
                case 1 :
                {
                    VectorMA ( vf_StartPos, 8.0, vf_Up );
                }
                case 2 :
                {
                    VectorMA ( vf_StartPos, 8.0, vf_Up );
                    VectorMA ( vf_StartPos, 8.0, vf_Right );
                }
                case 3 :
                {
                    VectorMA ( vf_StartPos, 8.0, vf_Right );
                }
                case 4 :
                {
                    VectorMA ( vf_StartPos, -8.0, vf_Up );
                    VectorMA ( vf_StartPos,  8.0, vf_Right );
                }
                case 5 :
                {
                    VectorMA ( vf_StartPos, -8.0, vf_Up );
                }
                case 6 :
                {
                    VectorMA ( vf_StartPos, -8.0, vf_Up );
                    VectorMA ( vf_StartPos, -8.0, vf_Right );
                }
                case 7 :
                {
                    VectorMA ( vf_StartPos, -8.0, vf_Right );
                }
                case 8 :
                {
                    VectorMA ( vf_StartPos,  8.0, vf_Up );
                    VectorMA ( vf_StartPos, -8.0, vf_Right );

                    gi_FirePhase = 0;
                }


            }

            set_pev ( gi_Hornet[ id ], pev_origin, vf_StartPos );
            set_pev ( gi_Hornet[ id ], pev_angles, vf_vAngles );
            set_pev ( gi_Hornet[ id ], pev_owner, id );

            xs_vec_mul_scalar ( vf_Forward, 1200.0, vf_Velocity );
            set_pev ( gi_Hornet[ id ], pev_velocity, vf_Velocity );

            engfunc ( EngFunc_VecToAngles, vf_Velocity, vf_vAngles );
            set_pev ( gi_Hornet[ id ], pev_angles, vf_vAngles );
        }

    }

    return gi_Hornet[ id ];
}


Hornet_Spawn ( const i_Hornet, const e_Firemode:i_Type )
{
    set_pev ( i_Hornet, pev_movetype, MOVETYPE_FLY );
    set_pev ( i_Hornet, pev_solid, SOLID_BBOX );
    set_pev ( i_Hornet, pev_flags, pev ( i_Hornet, pev_flags ) | FL_MONSTER );
    set_pev ( i_Hornet, pev_health, 1.0 );

    if ( random_num ( 1, 5 ) <= 2 )
    {
        set_pev ( i_Hornet, HG_TYPE_COLOR, HORNET_TYPE_RED );
        set_pev ( i_Hornet, HG_FLY_SPEED, HORNET_RED_SPEED );
    }
    else
    {
        set_pev ( i_Hornet, HG_TYPE_COLOR, HORNET_TYPE_ORANGE );
        set_pev ( i_Hornet, HG_FLY_SPEED, HORNET_ORANGE_SPEED );
    }

    if ( i_Type == Track )
        set_pev ( i_Hornet, HG_STOP_ATTACK, get_gametime () + 3.5 );

    engfunc ( EngFunc_SetModel, i_Hornet, gs_HornetModel );
    engfunc ( EngFunc_SetSize , i_Hornet, Float:{ -4.0, -4.0, -4.0 }, Float:{ 4.0, 4.0, 4.0 } );

    set_pev ( i_Hornet, HG_FIRE_MODE, Die );
    set_pev ( i_Hornet, HG_THINK_STEP, i_Type == Track ? StartTrack : StartDart );
    set_pev ( i_Hornet, pev_nextthink, get_gametime () + 0.1 );
}


Hornet_FireEffect ( const id )
{
    static Float:vf_Punchangle[ e_Coord ];
    vf_Punchangle[ x ] = float ( random_num( 0, 2 ) );

    set_pev ( id, pev_punchangle, vf_Punchangle );
    wpn_playanim ( id, hgun_shoot );

    switch ( random_num ( 0, 2 ) )
    {
        case 0 : emit_sound ( id, CHAN_WEAPON, gs_Fire1Sound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM );
        case 1 : emit_sound ( id, CHAN_WEAPON, gs_Fire2Sound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM );
        case 2 : emit_sound ( id, CHAN_WEAPON, gs_Fire3Sound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM );
    }
}


Hornet_Reload ( id )
{
    if ( !gf_RechargeTime[ id ] )
        return;

    gi_Weapon[ id ] = wpn_has_weapon ( id, gi_Weaponid );

    if ( gi_Weapon[ id ] == -1 )return
    static i_Ammo1;  i_Ammo1  = wpn_get_userinfo ( id, usr_wpn_ammo1, gi_Weapon[ id ] );

    if ( i_Ammo1 >= HIVEHAND_AMMO )
    {
        gf_RechargeTime[ id ] = 0.0;
        return;
    }

    while ( i_Ammo1 < HIVEHAND_AMMO && gf_RechargeTime[ id ] < get_gametime () )
    {
        i_Ammo1 = wpn_get_userinfo ( id, usr_wpn_ammo1, gi_Weapon[ id ] );
        wpn_set_userinfo ( id, usr_wpn_ammo1, gi_Weapon[ id ], i_Ammo1 + 1 );

        gf_RechargeTime[ id ] += HIVEGUN_REGEN_SPEED;
    }

}

public fwd_PostThink ( id )
if ( is_user_alive ( id ) && wpn_has_weapon ( id, gi_Weaponid ) )
    b_ReadyFire[id] = true


public fwd_PreThink ( id )
if(b_ReadyFire[id])
{
    Hornet_Reload ( id );
    WeaponIdle ( id );
}

public fwd_Think ( i_Ent )
{
    if ( !IsHornet ( i_Ent ) )
        return FMRES_IGNORED;

    switch ( pev ( i_Ent, HG_THINK_STEP ) )
    {
        case StartTrack :
        {
            IgniteTrail ( i_Ent );

            set_pev ( i_Ent, HG_FIRE_MODE, Track );
            set_pev ( i_Ent, HG_THINK_STEP, TrackTarget );
        }
        case StartDart :
        {
            IgniteTrail ( i_Ent );

            set_pev ( i_Ent, HG_FIRE_MODE, Fast );
            set_pev ( i_Ent, HG_THINK_STEP, RemoveHornet );

            set_pev ( i_Ent, pev_nextthink, get_gametime () + 4.0 );
            return FMRES_IGNORED;
        }
        case TrackTarget :
        {
            TrackingTarget ( i_Ent );
        }
        case RemoveHornet :
        {
            RemovingHornet ( i_Ent );
        }

    }
    set_pev ( i_Ent, pev_nextthink, get_gametime () + 0.1 );
    return FMRES_IGNORED;
}


public fwd_Touch ( i_Ent, i_Other )
{
    if ( !IsHornet ( i_Ent ) )
        return FMRES_IGNORED;

    switch ( pev ( i_Ent, HG_FIRE_MODE ) )
    {
        case Track : TrackTouch ( i_Ent, i_Other );
        case Fast  : DartTouch  ( i_Ent, i_Other );
        case Die   : DieTouch   ( i_Ent, i_Other );
    }

    return FMRES_IGNORED;
}


TrackTouch ( const i_Ent, const i_Other )
{
    if ( i_Other == pev ( i_Ent, pev_owner ) )
    {
        set_pev ( i_Ent, HG_FIRE_MODE, 0 );
        set_pev ( i_Ent, pev_solid, SOLID_NOT );

        return FMRES_IGNORED;
    }

    if ( !i_Other || IsHornet ( i_Other ) )
    {
        static Float:vf_Velocity[ e_Coord ];
        static Float:vf_Origin  [ e_Coord ];
        static Float:f_FlySpeed;

        pev ( i_Ent, pev_velocity, vf_Velocity );
        xs_vec_normalize ( vf_Velocity, vf_Velocity );

        vf_Velocity[ x ] *= -1.0;
        vf_Velocity[ y ] *= -1.0;

        pev ( i_Ent, pev_origin, vf_Origin );
        VectorMA ( vf_Origin, 4.0, vf_Velocity );

        if ( xs_vec_len ( vf_Origin ) > 0 )
            set_pev ( i_Ent, pev_origin, vf_Origin );

        pev ( i_Ent, HG_FLY_SPEED, f_FlySpeed );
        xs_vec_mul_scalar ( vf_Velocity, f_FlySpeed, vf_Velocity );

        if ( xs_vec_len ( vf_Velocity ) > 0 )
            set_pev ( i_Ent, pev_velocity, vf_Velocity );

        return FMRES_IGNORED;


    }

    DieTouch ( i_Ent, i_Other );

    return FMRES_IGNORED;
}


DartTouch ( const i_Ent, const i_Other )
{
    DieTouch ( i_Ent, i_Other );
}


DieTouch ( const i_Ent, const i_Other )
{
    if ( CanTakeDamage ( i_Other ) )
    {

        switch ( random_num ( 0, 2 ) )
        {
            case 0 : emit_sound ( i_Ent, CHAN_VOICE, gs_Hit1Sound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM );
            case 1 : emit_sound ( i_Ent, CHAN_VOICE, gs_Hit2Sound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM );
            case 2 : emit_sound ( i_Ent, CHAN_VOICE, gs_Hit3Sound, VOL_NORM, ATTN_NORM, 0, PITCH_NORM );
        }

        wpn_damage_user( gi_Weaponid, i_Other, pev ( i_Ent, pev_owner ), 0, HORNET_DAMAGE, DMG_BULLET | DMG_NEVERGIB );
    }
    else
    {
        wpn_damage_user(gi_Weaponid, i_Other, pev (i_Ent, pev_owner), 0, 0, DMG_BULLET | DMG_NEVERGIB);
    }

    set_pev ( i_Ent, pev_modelindex, 0 );
    set_pev ( i_Ent, pev_solid, SOLID_NOT );

    set_pev ( i_Ent, HG_THINK_STEP, RemoveHornet );
    set_pev ( i_Ent, pev_nextthink, get_gametime () + 1.0 );

    return FMRES_IGNORED;
}


BestVisibleEnemy ( const i_Ent, const Float:vf_Origin[] )
{
    static i_Target, i_Flags;

    static Float:vf_Mins   [ e_Coord ], Float:vf_Maxs   [ e_Coord ];
    static Float:vf_Absmins[ e_Coord ], Float:vf_Absmaxs[ e_Coord ];

    xs_vec_sub ( vf_Origin, Float:{ HORNET_SEARCH_RADIUS, HORNET_SEARCH_RADIUS, HORNET_SEARCH_RADIUS }, vf_Mins );
    xs_vec_add ( vf_Origin, Float:{ HORNET_SEARCH_RADIUS, HORNET_SEARCH_RADIUS, HORNET_SEARCH_RADIUS }, vf_Maxs );

    for ( i_Target = 1; i_Target < gi_MaxEntities; ++i_Target )
    {
        if ( !pev_valid ( i_Target ) )
        {
            continue;
        }

        i_Flags = pev ( i_Target, pev_flags );

        if ( !( i_Flags & ( FL_CLIENT | FL_FAKECLIENT | FL_MONSTER ) ) )
        {
            continue;
        }

        if ( i_Flags & FL_MONSTER )
        {
            if ( IsHornet ( i_Target ) )
            {
                continue;
            }
        }

        if ( i_Target == i_Ent )
        {
            continue;
        }

        pev ( i_Target, pev_absmin, vf_Absmins );
        pev ( i_Target, pev_absmax, vf_Absmaxs );

        if ( vf_Mins[ x ] > vf_Absmaxs[ x ] || vf_Mins[ y ] > vf_Absmaxs[ y ] || vf_Mins[ z ] > vf_Absmaxs[ z ] ||
             vf_Maxs[ x ] < vf_Absmins[ x ] || vf_Maxs[ y ] < vf_Absmins[ y ] || vf_Maxs[ z ] < vf_Absmins[ z ] )
        {
            continue;
        }

        if ( IsEnemyValid ( i_Ent, i_Target ) )
        {
            if ( FInViewCone ( i_Ent, i_Target ) && !( i_Flags & FL_NOTARGET ) && FVisible ( i_Ent, i_Target ) )
            {
                set_pev ( i_Ent, pev_enemy, i_Target );
                return i_Target;
            }

        }

    }
    return 0;
}


TrackingTarget ( i_Ent )
{
    if ( IsHornetShouldDie ( i_Ent ) )
    {
        set_pev ( i_Ent, HG_FIRE_MODE, 0 );
        set_pev ( i_Ent, HG_THINK_STEP, RemoveHornet );

        set_pev ( i_Ent, pev_nextthink, get_gametime () + 0.1 );
    }

    static Float:vf_FlightDir[ e_Coord ], Float:vf_DirToEnnemy[ e_Coord ];
    static Float:vf_EnemyLKP [ e_Coord ], Float:vf_Velocity   [ e_Coord ];
    static Float:vf_Origin   [ e_Coord ], Float:vf_Angles     [ e_Coord ];
    static Float:f_Delta, Float:f_FlySpeed, i_Enemy;

    pev ( i_Ent, pev_velocity, vf_Velocity );
    pev ( i_Ent, pev_origin  , vf_Origin   );

    i_Enemy = pev ( i_Ent, pev_enemy );

    if ( !IsEnemyValid ( i_Ent, i_Enemy ) )
    {
        set_pev ( i_Ent, pev_enemy, 0 );
        i_Enemy = 0;
    }

    if ( !i_Enemy )
        i_Enemy = BestVisibleEnemy ( i_Ent, vf_Origin );

    if ( i_Enemy != 0 && FVisible ( i_Ent, i_Enemy ) )
    {
        pev ( i_Enemy, pev_origin, vf_EnemyLKP );
        set_pev ( i_Ent, HG_ENEMY_LKP, vf_EnemyLKP );
    }
    else
    {
        pev ( i_Ent, HG_FLY_SPEED, f_FlySpeed );
        pev ( i_Ent, HG_ENEMY_LKP, vf_EnemyLKP );

        VectorMA ( vf_EnemyLKP, f_FlySpeed * 0.1, vf_Velocity );
        set_pev ( i_Ent, HG_ENEMY_LKP, vf_EnemyLKP );
    }

    pev ( i_Ent, pev_origin, vf_Origin );

    xs_vec_sub ( vf_EnemyLKP, vf_Origin, vf_Origin );
    xs_vec_normalize ( vf_Origin, vf_DirToEnnemy );

    xs_vec_len ( vf_Velocity ) < 0.1 ? xs_vec_copy ( vf_DirToEnnemy, vf_FlightDir ) : xs_vec_normalize ( vf_Velocity, vf_FlightDir );
    f_Delta = xs_vec_dot ( vf_FlightDir, vf_DirToEnnemy );

    if ( f_Delta < 0.5 )
    {
        switch ( random_num ( 0, 2 ) )
        {
            case 0 : emit_sound ( i_Ent, CHAN_VOICE, gs_Buzz1Sound, HORNET_BUZZ_VOLUME, ATTN_NORM, 0, PITCH_NORM );
            case 1 : emit_sound ( i_Ent, CHAN_VOICE, gs_Buzz2Sound, HORNET_BUZZ_VOLUME, ATTN_NORM, 0, PITCH_NORM );
            case 2 : emit_sound ( i_Ent, CHAN_VOICE, gs_Buzz3Sound, HORNET_BUZZ_VOLUME, ATTN_NORM, 0, PITCH_NORM );
        }

    }

    if ( f_Delta <= 0 && pev ( i_Ent, HG_TYPE_COLOR ) == HORNET_TYPE_RED )
        f_Delta = 0.25;

    xs_vec_add ( vf_FlightDir, vf_DirToEnnemy, vf_DirToEnnemy );
    xs_vec_normalize ( vf_DirToEnnemy, vf_Velocity );

    switch ( pev ( i_Ent, HG_TYPE_COLOR ) )
    {

        case HORNET_TYPE_RED :
        {
            pev ( i_Ent, HG_FLY_SPEED, f_FlySpeed );
            xs_vec_mul_scalar ( vf_Velocity, f_FlySpeed * f_Delta, vf_Velocity );

            set_pev ( i_Ent, pev_velocity, vf_Velocity );
            set_pev ( i_Ent, pev_nextthink, get_gametime () + random_float ( 0.1, 0.3 ) );
        }
        case HORNET_TYPE_ORANGE :
        {
            pev ( i_Ent, HG_FLY_SPEED, f_FlySpeed );
            xs_vec_mul_scalar ( vf_Velocity, f_FlySpeed, vf_Velocity );

            set_pev ( i_Ent, pev_velocity, vf_Velocity );
            set_pev ( i_Ent, pev_nextthink, get_gametime () + 0.1 );
        }


    }
    engfunc ( EngFunc_VecToAngles, vf_Velocity, vf_Angles );
    set_pev ( i_Ent, pev_angles, vf_Angles );
    set_pev ( i_Ent, pev_solid, SOLID_BBOX );
}


WeaponIdle ( id )
{
    static Float:f_Time; f_Time = get_gametime ();

    if ( gf_TimeWeaponIdle[ id ] > f_Time )
        return;

    static Float:f_Rand; f_Rand = random_float ( 0.0, 1.0 );

    if ( f_Rand <= 0.75 )
    {
        wpn_playanim ( id, hgun_idle1 );
        gf_TimeWeaponIdle[ id ] = f_Time + 30.0 / 16.0 * ( 2.0 );
    }
    else if ( f_Rand <= 0.875 )
    {
        wpn_playanim ( id, hgun_fidgetsway );
        gf_TimeWeaponIdle[ id ] = f_Time + 40.0 / 16.0;
    }
    else
    {
        wpn_playanim ( id, hgun_fidgetshake );
        gf_TimeWeaponIdle[ id ] = f_Time + 35.0 / 16.0;
    }

}


RemovingHornet ( const i_Ent )
    set_pev ( i_Ent, pev_flags, FL_KILLME );

IgniteTrail ( const i_Hornet )
{
    message_begin ( MSG_BROADCAST, SVC_TEMPENTITY );
    write_byte (  TE_BEAMFOLLOW );
    write_short ( i_Hornet );        // entity
    write_short ( gi_HornetTrail );  // model
    write_byte ( 10 );               // life
    write_byte ( 2 );                // width

    switch ( pev ( i_Hornet, HG_TYPE_COLOR ) )
    {
        case HORNET_TYPE_RED:
        {
            write_byte ( 179 );  // red
            write_byte ( 39 );   // green
            write_byte ( 14 );   // blue
        }
        case HORNET_TYPE_ORANGE:
        {
            write_byte ( 255 );  // red
            write_byte ( 128 );  // green
            write_byte ( 0 );    // blue
        }


    }

    write_byte ( 128 );          // brightness
    message_end ();
}


bool:IsHornetShouldDie ( const i_Ent )
{
    static Float:f_LifeTime; pev ( i_Ent, HG_STOP_ATTACK, f_LifeTime );

    if ( get_gametime () > f_LifeTime )
    {
        return true;
    }

    return false;
}


bool:IsEnemyValid ( const i_Ent, const i_Enemy )
{
    if ( !pev_valid ( i_Enemy ) )
    {
        return false;
    }

    static i_Flags; i_Flags = pev ( i_Enemy, pev_flags );

    if ( i_Flags & ( FL_CLIENT | FL_FAKECLIENT ) )
    {
        if ( !is_user_alive ( i_Enemy ) || pev ( i_Enemy, pev_deadflag ) > DEAD_NO )
        {
            return false;
        }
        else if ( !gi_FriendlyFire && IsSameTeam ( i_Enemy, pev ( i_Ent, pev_owner ) ) )
        {
            return false;
        }
    }
    else if ( i_Flags & FL_MONSTER )
    {
        static Float:f_Health; pev ( i_Enemy, pev_health, f_Health );

        if ( f_Health <= 0 )
        {
            return false;
        }
    }

    return true;
}


bool:CanTakeDamage ( i_Other )
{
    static Float:f_TakeDamage;
    pev ( i_Other, pev_takedamage, f_TakeDamage );

    if ( pev ( i_Other, pev_flags ) & ( FL_CLIENT | FL_FAKECLIENT | FL_MONSTER ) && f_TakeDamage != DAMAGE_NO )
    {
        return true;
    }

    return false;
}


bool:IsSameTeam ( const FirstId, const SecondId )
    return bool:( get_user_team ( FirstId ) == get_user_team ( SecondId ) );

bool:FVisible ( i_Hornet, i_Other )
{
    if ( !pev_valid ( i_Hornet ) || pev ( i_Other, pev_flags ) & FL_NOTARGET )
    {
        return false;
    }

    static i_LookerWLevel, i_TargetWLevel;

    i_LookerWLevel = pev ( i_Hornet, pev_waterlevel );
    i_TargetWLevel = pev ( i_Other , pev_waterlevel );

    if ( ( i_LookerWLevel != HEAD_IN_WATER && i_TargetWLevel == HEAD_IN_WATER ) ||
         ( i_LookerWLevel == HEAD_IN_WATER && i_TargetWLevel == NOT_IN_WATER  ) )
    {
        return false;
    }

    static Float:vf_LookerOrigin[ e_Coord ], Float:vf_TargetOrigin[ e_Coord ];

    EyePosition ( i_Hornet, vf_LookerOrigin );
    EyePosition ( i_Other , vf_TargetOrigin );

    engfunc ( EngFunc_TraceLine, vf_LookerOrigin, vf_TargetOrigin, IGNORE_MONSTERS, i_Hornet, 0 );

    static Float:f_Fraction;
    get_tr2 ( 0, TR_flFraction, f_Fraction );

    if ( f_Fraction == 1.0 )
    {
        return true;
    }

    return false;
}


bool:FInViewCone ( i_Hornet, i_Other )
{
    static Float:vf_Angles[ e_Coord ], Float:f_Dot;
    static Float:vf_HOrigin[ e_Coord ], Float:vf_Origin[ e_Coord ];

    pev ( i_Hornet, pev_angles, vf_Angles );

    engfunc ( EngFunc_MakeVectors, vf_Angles );
    global_get ( glb_v_forward, vf_Angles );

    vf_Angles[ z ] = 0.0;

    pev ( i_Hornet, pev_origin, vf_HOrigin );
    pev ( i_Other, pev_origin, vf_Origin );

    xs_vec_sub ( vf_Origin, vf_HOrigin, vf_Origin );
    vf_Origin[ z ] = 0.0;

    xs_vec_normalize ( vf_Origin, vf_Origin );
    f_Dot = xs_vec_dot ( vf_Origin, vf_Angles );

    if ( f_Dot > HORNET_FOV )
    {
        return true;
    }

    return false;
}


bool:IsAmmoEmpty ( const id, const wpn_usr_info:i_AmmoType )
{
    gi_Weapon[ id ] = wpn_has_weapon ( id, gi_Weaponid );
    return wpn_get_userinfo ( id, i_AmmoType, gi_Weapon[ id ] ) <= 0 ? true : false;
}


bool:IsHornet ( i_Ent )
{
    if ( !pev_valid ( i_Ent ) )
    {
        return false;
    }

    static s_Classname[ sizeof gs_HornetClassname + 1 ];
    pev ( i_Ent, pev_classname, s_Classname, charsmax ( s_Classname ) );

    if ( !FastCompare ( s_Classname, gs_HornetClassname, sizeof gs_HornetClassname ) )
    {
        return false;
    }

    return true;
}


bool:FastCompare (  const s_Source[], const s_What[], i_Wlen )
{
    static i; i = 0;

    while ( i_Wlen-- )
    {
        if ( s_Source[i] != s_What[i] )
        {
            return false;
        }

        ++i;
    }

    return true;
}


EyePosition ( const i_Ent, Float:vf_Origin[] )
{
    static Float:vf_ViewOfs[3];

    pev ( i_Ent, pev_origin, vf_Origin );
    pev ( i_Ent, pev_view_ofs, vf_ViewOfs );

    xs_vec_add ( vf_Origin, vf_ViewOfs, vf_Origin );
}


VectorMA ( Float:vf_Output[], const Float:f_Scale, const Float:vf_Mult[] )
{
    vf_Output[ x ] = vf_Output[ x ] + vf_Mult[ x ] * f_Scale;
    vf_Output[ y ] = vf_Output[ y ] + vf_Mult[ y ] * f_Scale;
    vf_Output[ z ] = vf_Output[ z ] + vf_Mult[ z ] * f_Scale;
}
